# Repository Guidelines

## Project Structure & Module Organization
Source code for features lives in `lib/`, organized by domain (auth, squads, shared widgets). Routing is handled through `lib/router` via `go_router`, while providers reside in `lib/application` for Riverpod usage. Tests mirror the `lib/` tree under `test/`. Platform runners (`android/`, `ios/`, `web/`, `linux/`, `macos/`, `windows/`) should remain untouched unless you are editing native integrations. Environment files sit in `.env` and `.env.EXAMPLE`; keep secrets out of git and document new keys in the example file. Local SQLite or mock data goes inside `db/`.

## Build, Test, and Development Commands
Run `flutter pub get` any time dependencies change. Use `flutter run -d chrome` for the default local web runner; `flutter run -d emulator-id` supports devices. `flutter test` executes the unit/widget test suite, and `flutter analyze` must be clean before opening a PR. Production builds rely on `flutter build web --release` or the corresponding platform-specific `flutter build` target. When code generation is needed (Riverpod/JSON), execute `dart run build_runner build --delete-conflicting-outputs`.

## Coding Style & Naming Conventions
Dart 3 features are allowed, but prefer const constructors, trailing commas, and null safety best practices. Widgets live in files using snake_case (`squad_card.dart`), classes use UpperCamelCase, and private members start with `_`. Follow Flutter’s default formatting via `dart format .` and keep imports sorted (package, third-party, local). Riverpod providers are suffixed with `Provider`, and JSON models expose `fromJson/toJson` factories generated by `json_serializable`.

## Testing Guidelines
Place widget tests under `test/widgets/` and provider logic under `test/application/`. Name files after the subject (`auth_controller_test.dart`). Aim for meaningful coverage on navigation flows and Supabase interactions; mock network or Supabase clients where possible. Run `flutter test --coverage` before feature branches merge and attach failing snapshots or logs to the PR if tests are flaky.

## Commit & Pull Request Guidelines
Recent history favors imperative, short commits such as `feat: implement authentication feature...`. Keep one logical change per commit and mention tickets with `#123` when relevant. Pull requests must include a concise summary, screenshots or screen recordings for UI-facing changes, steps to reproduce/test, and a checklist confirming `flutter analyze` and `flutter test` passed locally.
